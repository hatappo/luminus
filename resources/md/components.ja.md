## Managing Component Lifecycle

Luminusは、Webアプリケーションを書くのに[Clean Architecture](https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html)スタイルを適用することを推奨します。

Webアプリケーションの典型的なワークフローは、クライアントのリクエストが起点となります。クライアントからのリクエストは例えばデータベースのようなリソースとのやり取りをしばしば必要とするので、通常は各リクエストの経路（ルーティング）を制御してそれらのリソースへアクセスしなければいけません。ステートフルなコードを隔離するためには、トップレベルに副作用の管理を扱うための関数を用意すべきです。

ユーザ認証をより扱いやすくする経路を題材にして考えてみましょう。クライアントは、ユーザ名とパスワードをリクエストに入れるでしょう。このユーザ認証のルーティングでは、データベースからユーザのクリデンシャルを取ってきて、クライアントから渡された認証情報との突き合わせをしなければいけないはずです。それから、ユーザが問題なくログインできたか、あるいはできなかったのかを決定し、その成果物（訳注：認証トークンとか、ログイン成功を表す情報とか）をクライアントに返します。

このワークフローでは、DBという外部リソースを取り扱う部分のコードは、「データベース・アクセスを制御する名前空間とルーティング」を提供する独立した名前空間に限定隔離されるべきです。

上記のようなルーティングを制御する関数は、データベースからユーザのクリデンシャルを取得する関数を呼び出す責務を持つはずです。パスワードとユーザ名が一致するかどうかを判定するコードは、ビジネス・ロジックの中核を表現しています。このビジネス・ロジックのコードは、データベースにあるクリデンシャルととともにクライアントから渡されたクリデンシャルを受け入れ、そしてステートレスでなければいけません。この構造は以下の図のようになります。

```
            pure code
+----------+
| business |
|  logic   |
|          |
+-----+----+
      |
------|---------------------
      |     stateful code
+-----+----+   +-----------+
|  route   |   |           |
| handlers +---+  database |
|          |   |           |
+----------+   +-----------+
```

ビジネス・ロジックをステートレスに保つと、そのビジネス・ロジックの外のリソースを考慮することなしに、論理的に正しいかを検証し、そしてテストすることができるようになります。これは同時に、副作用のあるコードを外部の薄いレイヤーへ押し出します。するとコードの管理は楽になります。

## Managing Component Lifecycle

データベース・コネクションのようなステートフルなコンポーネントは、[mount](https://github.com/tolitius/mount)ライブラリで管理されます。`monut`ライブラリは、アプリケーション内のこれらステートフルなリソースのライフサイクルをうまく扱います。そして、あらゆるこれらステートフルなリソースが必要に応じて起動や停止されることを保証してくれます。

Luminusは、関連するドメイン・ロジックを一緒にまとめて管理することを助けてくれます。それゆえ、外部リソースに反応する関数がある場合には、それら外部リソースの状態管理をそのリソースを使用する関数が定義されたのと同じ名前空間で行うべきです。

ステートフルなコンポーネントは、そのコンポーネントが宣言された名前空間に所属します。コンポーネントを作成するには、名前空間の定義において`mount.core/defstate`マクロを参照する必要があります。そして、次のように使用します。

```clojure
(ns myapp.resource
  (:require [mount.core :refer [defstate]]))

(defn connect []
  ;; open-a-remote-connection はコネクションのインスタンスを返さなければいけません。
  {:state :connected})
  
(defn disconnect [conn]
  (assoc conn :state :disconnected))

(defstate conn
  :start (connect)
  :stop (disconnect conn))
```

コンポーネントが起動されると、`:start`キーに束縛された関数が呼び出されます。`:start`キーに束縛されたこの関数の実行結果は、コネクションの状態を表す値として使用されます。先の例では、`conn`は`connect`関数が返すmapを保持するでしょう。

コンポーネントが停止されると、`:stop`キーに束縛された関数が呼び出されます。この関数は、varの現在の状態を受け取ることができなければいけません。`:stop`キーに束縛されたこの関数の役割は、コンポーネントが停止する前に全ての外部リソースを綺麗に始末することです。

コンポーネントの依存関係は、名前空間の階層構造から推測されます。もし、名前空間`a`が名前空間`b`を参照していて、名前空間`b`内で`defstate`によって明示されるコンポーネントがあるとします。このコンポーネントは、名前空間`a`で明示されるコンポーネントよりも前に起動されるでしょう。システムが停止されると、それぞれの状態（訳注：`defstate`されたコンポーネント）の`:stop`キーの関数が、起動とは逆の順序で呼び出されます。

例えば、ある設定情報とその設定情報を利用してデータベースへ接続する別の設定情報という2つの設定コンポーネントをロードする名前空間があるとします。これは次のように表現されます。

```clojure
(ns app.db
  (:require [mount.core :refer [defstate]]
            [app.config :refer [app-config]]))

(defn connect! [config] ...)

(defn disconnect! [conn] ...)

(defstate conn :start (connect! app-config)
               :stop (disconnect! conn))
```

コンポーネント階層は`mount.core/start`の呼び出しで初期化され、`mount.core/stop`によって停止されます。この処理は、`<app>.handler/init`関数と`<app>.handler/init`関数によって、それぞれ行われます。

これらの関数は、REPLから使用することもできます。その場合、REPL自体をリスタートすることなしに、システムを綺麗な状態にリロードできます。以下のような感じです。

```clojure
(ns repl
  (:require [clojure.tools.namespace.repl :as tn]
            [mount.core :as mount]))

(defn go
  "defstaeで定義された全ての状態を開始します"
  []
  (mount/start)
  :ready)

(defn reset
  "defstateで定義された全ての状態を停止し、変更のあるソース・ファイルをリロードし、全ての状態をリスタートします。"
  "stops all states defined by defstate, reloads modified source files, and restarts the states"
  []
  (mount/stop)
  (tn/refresh :after 'repl/go))
```

起動や停止をする名前空間を`start`や`stop`関数に明示的に渡すことによって、任意の状態だけを選択的に起動することもできます。

```clojure
(mount.core/start #'app.config #'app.db)

(mount.core/stop #'app.config #'app.db)
```

逆に`start-without`関数を使えば、任意の名前空間をライフサイクル管理から除外するように指定できます。

```
(start-without #'app.db)
```

後は、`start-with`関数を使えば、例えばテスト用のモックのような代替コンポーネントで置き換えるということができます。

```
(start-with #'app.db #'app.test.mock-db)
```

上記の例では、コンポーネントがロードされると`app.db`が`app.test.mock-db`に置き換えられます。
